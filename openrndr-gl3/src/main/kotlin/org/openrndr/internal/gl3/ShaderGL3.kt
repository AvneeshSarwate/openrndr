package org.openrndr.internal.gl3

import org.openrndr.draw.Shader
import org.openrndr.math.Matrix44
import org.openrndr.math.Vector2
import org.openrndr.math.Vector3
import org.openrndr.math.Vector4

import mu.KotlinLogging
import org.lwjgl.BufferUtils
import org.lwjgl.opengl.GL11.*
import org.lwjgl.opengl.GL20.*
import org.openrndr.color.ColorRGBa
import java.io.File
import java.io.FileWriter
import java.nio.Buffer
import java.nio.ByteBuffer

private val logger = KotlinLogging.logger {}

fun checkShaderInfoLog(`object`: Int, code: String, sourceFile: String) {

    logger.debug { "getting shader info log" }
    val logLength = IntArray(1)
    glGetShaderiv(`object`, GL_INFO_LOG_LENGTH, logLength)
    logger.debug { "log length: ${logLength[0]}" }

    if (logLength[0] > 0) {

        logger.debug { "getting log" }
        val infoLog = BufferUtils.createByteBuffer(logLength[0])
        (infoLog as Buffer).rewind()
        glGetShaderInfoLog(`object`, logLength, infoLog)

       // logger.warn {
            val infoBytes = ByteArray(logLength[0])
            infoLog.get(infoBytes)
            println("GLSL compilation problems in\n ${String(infoBytes)}")
         //   "GLSL compilation problems in\n ${String(infoBytes)}"
       // }

        val temp = File("ShaderError.txt")
        FileWriter(temp).use {
            it.write(code)
        }
        System.err.println("click.to.see.shader.code(ShaderError.txt:1)")
        logger.error { "GLSL shader compilation failed for $sourceFile" }
        throw Exception("Shader error: " + sourceFile)
    }
}

fun checkProgramInfoLog(`object`: Int, sourceFile: String) {

    val logLength = IntArray(1)
    glGetProgramiv(`object`, GL_INFO_LOG_LENGTH, logLength)

    if (logLength[0] > 1) {
        val infoLog = BufferUtils.createByteBuffer(logLength[0])
        glGetProgramInfoLog(`object`, logLength, infoLog)
        val infoBytes = ByteArray(logLength[0])
        infoLog.get(infoBytes)
        println("GLSL link problems in\n ${String(infoBytes)}")


        logger.warn {
            val infoBytes = ByteArray(logLength[0])
            infoLog.get(infoBytes)
            "GLSL link problems in\n ${String(infoBytes)}"
        }
        throw Exception("Shader error: " + sourceFile)

    }
}


class ShaderGL3(val program: Int,
                val name: String,
                val vertexShader: VertexShaderGL3,
                val fragmentShader: FragmentShaderGL3) : Shader {

    private var running = false
    private var uniforms: MutableMap<String, Int> = hashMapOf()
    private var attributes: MutableMap<String, Int> = hashMapOf()

    companion object {
        fun create(vertexShader: VertexShaderGL3, fragmentShader: FragmentShaderGL3): ShaderGL3 {

            debugGLErrors()
            var name = "${vertexShader.name} / ${fragmentShader.name}"

            val program = glCreateProgram()
            debugGLErrors()

            glAttachShader(program, vertexShader.shaderObject)
            debugGLErrors()

            glAttachShader(program, fragmentShader.shaderObject)
            debugGLErrors()

            glLinkProgram(program)
            debugGLErrors()

            val linkStatus = IntArray(1)
            glGetProgramiv(program, GL_LINK_STATUS, linkStatus)
            debugGLErrors()

            if (linkStatus[0] != GL_TRUE) {
                checkProgramInfoLog(program, "noname")
            }

            return ShaderGL3(program, name, vertexShader, fragmentShader)

        }
    }

    fun uniformIndex(uniform: String): Int =
            uniforms.getOrPut(uniform) {
                val location = glGetUniformLocation(program, uniform)
                debugGLErrors()
                if (location == -1) {
                    logger.warn {
                        "shader ${name} does not have uniform $uniform"
                    }
                }
                location
            }

    override fun begin() {
        logger.trace { "shader begin $name" }
        running = true
        glUseProgram(program)
        debugGLErrors {
            when(it) {
                GL_INVALID_VALUE -> "program is neither 0 nor a value generated by OpenGL"
                GL_INVALID_OPERATION -> "program ($program) is not a program object / program could not be made part of current state / transform feedback mode is active."
                else -> null
            }
        }

    }

    override fun end() {
        logger.trace { "shader end $name" }
//        glUseProgram(0)
        debugGLErrors()
        running = false
    }


    override fun uniform(name: String, value: ColorRGBa) {
        val index = uniformIndex(name)
        if (index != -1) {
            glUniform4f(index, value.r.toFloat(), value.g.toFloat(), value.b.toFloat(), value.a.toFloat())
            debugGLErrors()
        }
    }

    override fun uniform(name: String, value: Vector3) {
        val index = uniformIndex(name)
        if (index != -1) {
            glUniform3f(index, value.x.toFloat(), value.y.toFloat(), value.z.toFloat())
            debugGLErrors()
        }
    }

    override fun uniform(name: String, value: Vector4) {
        val index = uniformIndex(name)
        if (index != -1) {
            glUniform4f(index, value.x.toFloat(), value.y.toFloat(), value.z.toFloat(), value.w.toFloat())
            debugGLErrors()
        }
    }

    override fun uniform(name: String, value: Int) {
        val index = uniformIndex(name)
        if (index != -1) {
            glUniform1i(index, value)
            debugGLErrors()
        }

    }

    override fun uniform(name: String, value: Vector2) {
        val index = uniformIndex(name)
        if (index != -1) {
            glUniform2f(index, value.x.toFloat(), value.y.toFloat())
            debugGLErrors()
        }
    }

    override fun uniform(name: String, value: Float) {
        val index = uniformIndex(name)
        if (index != -1) {
            glUniform1f(index, value)
            debugGLErrors()
        }
    }

    override fun uniform(name: String, value: Double) {
        val index = uniformIndex(name)
        if (index != -1) {
            glUniform1f(index, value.toFloat())
            debugGLErrors()
        }
    }

    override fun uniform(name: String, value: Matrix44) {
        val index = uniformIndex(name)
        if (index != -1) {
            logger.trace { "Setting uniform '$name' to $value" }
            glUniformMatrix4fv(index, false, value.toFloatArray())
            debugGLErrors() {
                val currentProgram =  glGetInteger(GL_CURRENT_PROGRAM)
                when(it) {

                    GL_INVALID_OPERATION -> "no current program object ($currentProgram)"
                    else -> null
                }
            }
        }
    }

    override fun uniform(name:String, value:Array<Vector2>) {
        val index = uniformIndex(name)
        if (index != -1) {
            logger.trace { "Setting uniform '$name' to $value" }

            val floatValues = FloatArray(value.size*2)
            for (i in 0 until value.size) {
                floatValues[i*2] = value[i].x.toFloat()
                floatValues[i*2+1] = value[i].y.toFloat()
            }

            glUniform2fv(index, floatValues)
            debugGLErrors {
                val currentProgram =  glGetInteger(GL_CURRENT_PROGRAM)
                when(it) {
                    GL_INVALID_OPERATION -> "no current program object ($currentProgram)"
                    else -> null
                }
            }
        }

    }

    override fun uniform(name:String, value:Array<Vector3>) {
        val index = uniformIndex(name)
        if (index != -1) {
            logger.trace { "Setting uniform '$name' to $value" }

            val floatValues = FloatArray(value.size*3)
            for (i in 0 until value.size) {
                floatValues[i*3] = value[i].x.toFloat()
                floatValues[i*3+1] = value[i].y.toFloat()
                floatValues[i*3+2] = value[i].z.toFloat()
            }

            glUniform3fv(index, floatValues)
            debugGLErrors {
                val currentProgram =  glGetInteger(GL_CURRENT_PROGRAM)
                when(it) {
                    GL_INVALID_OPERATION -> "no current program object ($currentProgram)"
                    else -> null
                }
            }
        }
    }

    override fun uniform(name:String, value:Array<Vector4>) {
        val index = uniformIndex(name)
        if (index != -1) {
            logger.trace { "Setting uniform '$name' to $value" }

            val floatValues = FloatArray(value.size*4)
            for (i in 0 until value.size) {
                floatValues[i*4] = value[i].x.toFloat()
                floatValues[i*4+1] = value[i].y.toFloat()
                floatValues[i*4+2] = value[i].z.toFloat()
                floatValues[i*4+3] = value[i].w.toFloat()
            }

            glUniform4fv(index, floatValues)
            debugGLErrors {
                val currentProgram = glGetInteger(GL_CURRENT_PROGRAM)
                when(it) {
                    GL_INVALID_OPERATION -> "no current program object ($currentProgram)"
                    else -> null
                }
            }
        }
    }

    override fun uniform(name:String, value:FloatArray) {
        val index = uniformIndex(name)
        if (index != -1) {
            logger.trace { "Setting uniform '$name' to $value" }
            glUniform1fv(index, value)
            debugGLErrors {
                val currentProgram = glGetInteger(GL_CURRENT_PROGRAM)
                when(it) {
                    GL_INVALID_OPERATION -> "no current program object ($currentProgram)"
                    else -> null
                }
            }
        }
    }

    fun attributeIndex(name: String): Int =
            attributes.getOrPut(name, {
                val location = glGetAttribLocation(program, name)
                debugGLErrors()
                location
            })
}

